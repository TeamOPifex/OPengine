<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Code Samples</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mini.png"></td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="index.html">OpenGL Mathematics</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Code Samples </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><p>This series of samples only shows various GLM functionality.</p>
<h2><a class="anchor" id="sample1"></a>
Compute a Triangle's Normal</h2>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;glm/glm.hpp&gt;</span> <span class="comment">// vec3 normalize cross</span>
 
<a class="code" href="a00021.html" title="Basic 3D vector type.">glm::vec3</a> computeNormal(
<a class="code" href="a00021.html" title="Basic 3D vector type.">glm::vec3</a> <span class="keyword">const</span> &amp; a, 
<a class="code" href="a00021.html" title="Basic 3D vector type.">glm::vec3</a> <span class="keyword">const</span> &amp; b,
<a class="code" href="a00021.html" title="Basic 3D vector type.">glm::vec3</a> <span class="keyword">const</span> &amp; c)
{
        <span class="keywordflow">return</span> <a class="code" href="a00231.html#ga07ff16965f11fa17122ac874ed492276" title="Returns a vector in the same direction as x but with length of 1.">glm::normalize</a>(<a class="code" href="a00231.html#ga63272179a066d755953bcfbe38666257" title="Returns the cross product of x and y.">glm::cross</a>(c - a, b - a));
}
</pre></div><p>A potentially faster, but less accurate alternative:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;glm/glm.hpp&gt;</span> <span class="comment">// vec3 cross</span>
<span class="preprocessor">#include &lt;glm/gtx/fast_square_root.hpp&gt;</span> <span class="comment">// fastNormalize</span>
 
<a class="code" href="a00021.html" title="Basic 3D vector type.">glm::vec3</a> computeNormal(
        <a class="code" href="a00021.html" title="Basic 3D vector type.">glm::vec3</a> <span class="keyword">const</span> &amp; a, 
        <a class="code" href="a00021.html" title="Basic 3D vector type.">glm::vec3</a> <span class="keyword">const</span> &amp; b,
        <a class="code" href="a00021.html" title="Basic 3D vector type.">glm::vec3</a> <span class="keyword">const</span> &amp; c)
{
        <span class="keywordflow">return</span> <a class="code" href="a00255.html#ga7e785d24d7bbac63f273baf9af1160da" title="Faster than the common normalize function but less accurate.">glm::fastNormalize</a>(<a class="code" href="a00231.html#ga63272179a066d755953bcfbe38666257" title="Returns the cross product of x and y.">glm::cross</a>(c - a, b - a));
}
</pre></div><h2><a class="anchor" id="sample2"></a>
Matrix Transform</h2>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;glm/glm.hpp&gt;</span> <span class="comment">//vec3, vec4, ivec4, mat4</span>
<span class="preprocessor">#include &lt;glm/gtc/matrix_transform.hpp&gt;</span> <span class="comment">//translate, rotate, scale, perspective </span>
<span class="preprocessor">#include &lt;glm/gtc/type_ptr.hpp&gt;</span> <span class="comment">//value_ptr</span>
 
<span class="keywordtype">void</span> setUniformMVP(
                GLuint Location, 
                <a class="code" href="a00021.html" title="Basic 3D vector type.">glm::vec3</a> <span class="keyword">const</span> &amp; Translate, 
                <a class="code" href="a00021.html" title="Basic 3D vector type.">glm::vec3</a> <span class="keyword">const</span> &amp; Rotate)
{
        <a class="code" href="a00018.html" title="Template for 4 * 4 matrix of floating-point numbers.">glm::mat4</a> Projection =
        <a class="code" href="a00237.html#ga1bb3652e43f824d8c1dd5b9e60c80437" title="Creates a matrix for a symetric perspective-view frustum.">glm::perspective</a>(45.0f, 4.0f / 3.0f, 0.1f, 100.f);
        <a class="code" href="a00018.html" title="Template for 4 * 4 matrix of floating-point numbers.">glm::mat4</a> ViewTranslate = <a class="code" href="a00237.html#ga4683c446c8432476750ade56f2537397" title="Builds a translation 4 * 4 matrix created from a vector of 3 components.">glm::translate</a>(
        <a class="code" href="a00018.html" title="Template for 4 * 4 matrix of floating-point numbers.">glm::mat4</a>(1.0f),
        Translate);
        <a class="code" href="a00018.html" title="Template for 4 * 4 matrix of floating-point numbers.">glm::mat4</a> ViewRotateX = <a class="code" href="a00237.html#ga48168ff70412019857ceb28b3b2b1f5e" title="Builds a rotation 4 * 4 matrix created from an axis vector and an angle expressed in degrees...">glm::rotate</a>(
        ViewTranslate,
        Rotate.y, <a class="code" href="a00021.html" title="Basic 3D vector type.">glm::vec3</a>(-1.0f, 0.0f, 0.0f));
        <a class="code" href="a00018.html" title="Template for 4 * 4 matrix of floating-point numbers.">glm::mat4</a> View = <a class="code" href="a00237.html#ga48168ff70412019857ceb28b3b2b1f5e" title="Builds a rotation 4 * 4 matrix created from an axis vector and an angle expressed in degrees...">glm::rotate</a>(
        ViewRotateX,
        Rotate.x, <a class="code" href="a00021.html" title="Basic 3D vector type.">glm::vec3</a>(0.0f, 1.0f, 0.0f));
        <a class="code" href="a00018.html" title="Template for 4 * 4 matrix of floating-point numbers.">glm::mat4</a> Model = <a class="code" href="a00237.html#ga6da77ee2c33d0d33de557a37ff35b197" title="Builds a scale 4 * 4 matrix created from 3 scalars.">glm::scale</a>(
        <a class="code" href="a00018.html" title="Template for 4 * 4 matrix of floating-point numbers.">glm::mat4</a>(1.0f),
        <a class="code" href="a00021.html" title="Basic 3D vector type.">glm::vec3</a>(0.5f));
        <a class="code" href="a00018.html" title="Template for 4 * 4 matrix of floating-point numbers.">glm::mat4</a> MVP = Projection * View * Model;
        glUniformMatrix4fv(
        Location, 1, GL_FALSE, <a class="code" href="a00240.html#ga5075091661217b41a4ea947a9aa3c21e" title="Get the const address of the vector content.">glm::value_ptr</a>(MVP));
}
</pre></div><h2><a class="anchor" id="sample3"></a>
Vector Types</h2>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;glm/glm.hpp&gt;</span> <span class="comment">//vec2</span>
<span class="preprocessor">#include &lt;glm/gtc/type_precision.hpp&gt;</span> <span class="comment">//hvec2, i8vec2, i32vec2</span>
std::size_t <span class="keyword">const</span> VertexCount = 4;
 
<span class="comment">// Float quad geometry</span>
std::size_t <span class="keyword">const</span> PositionSizeF32 = VertexCount * <span class="keyword">sizeof</span>(glm::vec2);
glm::vec2 <span class="keyword">const</span> PositionDataF32[VertexCount] =
{
        glm::vec2(-1.0f,-1.0f),
        glm::vec2( 1.0f,-1.0f),
        glm::vec2( 1.0f, 1.0f),
        glm::vec2(-1.0f, 1.0f)
};

<span class="comment">// Half-float quad geometry</span>
std::size_t <span class="keyword">const</span> PositionSizeF16 = VertexCount * <span class="keyword">sizeof</span>(<a class="code" href="a00233.html#ga2cd0b3fe113dc1aa2ee750a85f77c50a" title="Vector of 2 half-precision floating-point numbers.">glm::hvec2</a>);
<a class="code" href="a00020.html" title="The basic 2D vector type.">glm::hvec2</a> <span class="keyword">const</span> PositionDataF16[VertexCount] =
{
        <a class="code" href="a00233.html#ga2cd0b3fe113dc1aa2ee750a85f77c50a" title="Vector of 2 half-precision floating-point numbers.">glm::hvec2</a>(-1.0f, -1.0f),
        <a class="code" href="a00233.html#ga2cd0b3fe113dc1aa2ee750a85f77c50a" title="Vector of 2 half-precision floating-point numbers.">glm::hvec2</a>( 1.0f, -1.0f),
        <a class="code" href="a00233.html#ga2cd0b3fe113dc1aa2ee750a85f77c50a" title="Vector of 2 half-precision floating-point numbers.">glm::hvec2</a>( 1.0f, 1.0f),
        <a class="code" href="a00233.html#ga2cd0b3fe113dc1aa2ee750a85f77c50a" title="Vector of 2 half-precision floating-point numbers.">glm::hvec2</a>(-1.0f, 1.0f)
};

<span class="comment">// 8 bits signed integer quad geometry</span>
std::size_t <span class="keyword">const</span> PositionSizeI8 = VertexCount * <span class="keyword">sizeof</span>(<a class="code" href="a00239.html#ga9ab3f26fa232d5a4d2397d7904eb9069" title="8bit signed integer vector of 2 components. (from GLM_GTC_type_precision extension)">glm::i8vec2</a>);
<a class="code" href="a00020.html" title="The basic 2D vector type.">glm::i8vec2</a> <span class="keyword">const</span> PositionDataI8[VertexCount] =
{
        <a class="code" href="a00239.html#ga9ab3f26fa232d5a4d2397d7904eb9069" title="8bit signed integer vector of 2 components. (from GLM_GTC_type_precision extension)">glm::i8vec2</a>(-1,-1),
        <a class="code" href="a00239.html#ga9ab3f26fa232d5a4d2397d7904eb9069" title="8bit signed integer vector of 2 components. (from GLM_GTC_type_precision extension)">glm::i8vec2</a>( 1,-1),
        <a class="code" href="a00239.html#ga9ab3f26fa232d5a4d2397d7904eb9069" title="8bit signed integer vector of 2 components. (from GLM_GTC_type_precision extension)">glm::i8vec2</a>( 1, 1),
        <a class="code" href="a00239.html#ga9ab3f26fa232d5a4d2397d7904eb9069" title="8bit signed integer vector of 2 components. (from GLM_GTC_type_precision extension)">glm::i8vec2</a>(-1, 1)
};

<span class="comment">// 32 bits signed integer quad geometry</span>
std::size_t <span class="keyword">const</span> PositionSizeI32 = VertexCount * <span class="keyword">sizeof</span>(<a class="code" href="a00239.html#ga587a33330386e50f7ff9a870f1b62ab1" title="32bit signed integer vector of 2 components. (from GLM_GTC_type_precision extension)">glm::i32vec2</a>);
<a class="code" href="a00020.html" title="The basic 2D vector type.">glm::i32vec2</a> <span class="keyword">const</span> PositionDataI32[VertexCount] =
{
        <a class="code" href="a00239.html#ga587a33330386e50f7ff9a870f1b62ab1" title="32bit signed integer vector of 2 components. (from GLM_GTC_type_precision extension)">glm::i32vec2</a> (-1,-1),
        <a class="code" href="a00239.html#ga587a33330386e50f7ff9a870f1b62ab1" title="32bit signed integer vector of 2 components. (from GLM_GTC_type_precision extension)">glm::i32vec2</a> ( 1,-1),
        <a class="code" href="a00239.html#ga587a33330386e50f7ff9a870f1b62ab1" title="32bit signed integer vector of 2 components. (from GLM_GTC_type_precision extension)">glm::i32vec2</a> ( 1, 1),
        <a class="code" href="a00239.html#ga587a33330386e50f7ff9a870f1b62ab1" title="32bit signed integer vector of 2 components. (from GLM_GTC_type_precision extension)">glm::i32vec2</a> (-1, 1)
};
</pre></div><h2><a class="anchor" id="sample4"></a>
Lighting</h2>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;glm/glm.hpp&gt;</span> <span class="comment">// vec3 normalize reflect dot pow</span>
<span class="preprocessor">#include &lt;glm/gtx/random.hpp&gt;</span> <span class="comment">// vecRand3</span>
 
<span class="comment">// vecRand3, generate a random and equiprobable normalized vec3</span>
 
<a class="code" href="a00021.html" title="Basic 3D vector type.">glm::vec3</a> lighting(
        intersection <span class="keyword">const</span> &amp; Intersection,
        material <span class="keyword">const</span> &amp; Material,
        light <span class="keyword">const</span> &amp; Light,
        <a class="code" href="a00021.html" title="Basic 3D vector type.">glm::vec3</a> <span class="keyword">const</span> &amp; View)
{
        <a class="code" href="a00021.html" title="Basic 3D vector type.">glm::vec3</a> Color = <a class="code" href="a00228.html#gac422c7058a7c9963b55ad70764c62752" title="3 components vector of floating-point numbers.">glm::vec3</a>(0.0f);
        <a class="code" href="a00021.html" title="Basic 3D vector type.">glm::vec3</a> LightVertor = <a class="code" href="a00231.html#ga07ff16965f11fa17122ac874ed492276" title="Returns a vector in the same direction as x but with length of 1.">glm::normalize</a>(
        Light.position() - Intersection.globalPosition() +
        <a class="code" href="a00280.html#ga63249d58e1327a83638f1cf8b421a0de" title="Generate a random normalized 3 component vector. It&amp;#39;s a spherical uniform distribution. (From GLM_GTX_random extension)">glm::vecRand3</a>(0.0f, Light.inaccuracy());
        
        <span class="keywordflow">if</span>(!shadow(
                Intersection.globalPosition(),
                Light.position(),
                LightVertor))
        {
                <span class="keywordtype">float</span> Diffuse = <a class="code" href="a00231.html#ga38e1f1538ac0fedc9d6ac14910105421" title="Returns the dot product of x and y, i.e., result = x * y.">glm::dot</a>(Intersection.normal(), LightVector);
                <span class="keywordflow">if</span>(Diffuse &lt;= 0.0f)
                <span class="keywordflow">return</span> Color;
                <span class="keywordflow">if</span>(Material.isDiffuse())
                Color += Light.color() * Material.diffuse() * Diffuse;
                
        <span class="keywordflow">if</span>(Material.isSpecular())
        {
                <a class="code" href="a00021.html" title="Basic 3D vector type.">glm::vec3</a> Reflect = <a class="code" href="a00231.html#ga2863d2331eb3752a5a17244c604c1d07" title="For the incident vector I and surface orientation N, returns the reflection direction : result = I - ...">glm::reflect</a>(
                -LightVector,
                Intersection.normal());
                <span class="keywordtype">float</span> Dot = <a class="code" href="a00231.html#ga38e1f1538ac0fedc9d6ac14910105421" title="Returns the dot product of x and y, i.e., result = x * y.">glm::dot</a>(Reflect, View);
                <span class="keywordtype">float</span> Base = Dot &gt; 0.0f ? Dot : 0.0f;
                <span class="keywordtype">float</span> Specular = <a class="code" href="a00231.html#ga8eb76dfbf0fed3397c0327915279f06f" title="Returns x raised to the y power.">glm::pow</a>(Base, Material.exponent());
                Color += Material.specular() * Specular;
        }
        <span class="keywordflow">return</span> Color;
}
</pre></div> </div></div>
<hr class="footer"/><address class="footer"><small>Generated by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
